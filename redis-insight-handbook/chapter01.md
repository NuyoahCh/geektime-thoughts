2015 年的时候，我和我的团队接到了一个高难度任务，目标是设计一个单机性能达到千万级吞吐量的键值数据库。为了实现这个目标，我们就开始重点研究 Redis，从此，我就和这个数据库结缘了。

> 由问题的产生，开始相关技术的钻研。
>



这里贴一张由 MacBookPro 本机，由 Docker 的方式部署 Redis 5.0.5 进行测试的效果图。

![](https://cdn.nlark.com/yuque/0/2025/png/45054063/1761203724276-066c54d5-5bac-4072-becd-cd8cdeea598d.png)

看到Redis是秒级十万操作，性能真的是十分强大。



Redis 存在的坑：

+ CPU 使用上的“坑”，例如数据结构的复杂度、跨 CPU 核的访问；
+ 内存使用上的“坑”，例如主从同步和 AOF 的内存竞争；
+ 存储持久化上的“坑”，例如在 SSD 上做快照的性能抖动；
+ 网络通信上的“坑”，例如多实例时的异常网络丢包。



存在问题：

现在，很多大厂的 Redis 服务面临的请求规模很大，因此，在评估性能时，仅仅看平均延迟已经不够了。

我简单举个例子，假设 Redis 处理了 100 个请求，99 个请求的响应时间都是 1s，而有一个请求的响应时间是 100s。那么，如果看平均延迟，这 100 个请求的平均延迟是 1.99s，但是对于这个响应时间是 100s 的请求而言，它对应的用户体验将是非常糟糕的。如果有 100 万个请求，哪怕只有 1% 的请求是 100s，这也对应了 1 万个糟糕的用户体验。这 1% 的请求延迟就属于长尾延迟。



思路分析：

首先，我对 Redis 的线程模型做了分析，我发现，对于单线程的 Redis 而言，任何阻塞性操作都会导致长尾延迟的产生。接着，我又开始寻找可能导致阻塞的关键因素，一开始想到的是网络阻塞，但随着对 Redis 网络框架的理解，我知道 Redis 网络 IO 使用了 IO 复用机制，并不会阻塞在单个客户端上。



再后来，我又把目光转向了键值对数据结构、持久化机制下的 fork 调用、主从库同步时的 AOF 重写，以及缓冲区溢出等多个方面。



绕了一大圈子之后，这条影响长尾延迟的“证据链”才得以形成。这样一来，我也系统地掌握了影响 Redis 性能的关键因素路径，之后再碰到类似的问题时，我就可以轻松解决了。



两大维度，三大主线：

![](https://cdn.nlark.com/yuque/0/2025/png/45054063/1761204154385-8c56aae3-e719-441d-ba9b-d20c2fbde7dc.png)

“两大维度”就是指系统维度和应用维度，“三大主线”也就是指高性能、高可靠和高可扩展（可以简称为“三高”）。

+ 高性能主线，包括线程模型、数据结构、持久化、网络框架；
+ 高可靠主线，包括主从复制、哨兵机制；
+ 高可扩展主线，包括数据分片、负载均衡。



Redis 存在的问题

![](https://cdn.nlark.com/yuque/0/2025/png/45054063/1761204248994-a6672960-cc7f-4d6f-9154-90956b600f1b.png)



最后，我想说，Redis 是一个非常优秀的系统，它在 CPU 使用、内存组织、存储持久化和网络通信这四大方面的设计非常经典，而这些，基本涵盖了一个优秀的后端系统工程师需要掌握的核心知识和关键技术。希望你通过这个课程的学习，成长为一名优秀的系统工程师。



通过本节课程的学习，产生的自己的思考，不单单停留在 Redis 中，对于任何项目的学习，我们需要的是带着问题去找答案，以问题驱动的方式去学习相关的技术，这样才不会走马观花。





